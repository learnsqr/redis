<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Redis Ready: High Disponibility - Learnsqr</title>

		<meta name="description" content="Redis Ready - A Talk about Redis.">
		<meta name="author" content="Agustín F. Calderón M.">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="../assets/vendor/reveal.js/css/reveal.css">
		<link rel="stylesheet" href="../assets/vendor/reveal.js/css/theme/moon.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="../assets/vendor/reveal.js/lib/css/zenburn.css">
		
		<link rel="stylesheet" href="../assets/css/style.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = '../assets/vendor/reveal.js/css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
		
		      
        
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				
				<section>
                    <h1>
                        <span class="mysql-color">High Availability</span>                        
                    </h1>
                </section>
<!-- *************** SLIDES BEGIN ********************* -->

<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Redis Sentinel<center>

<span class="zf-color">Monitoring</span> Cnstantly checks if your master and slave instances are working as expected.  
<span class="zf-color">Notification</span> Can notify the system administrator, another computer programs, via an API.  
<span class="zf-color">Automatic failover</span> If a master is not working as expected, Sentinel can start a failover process.  
<span class="zf-color">Configuration provider</span> Acts as a source of authority for clients service discovery.  

</script>
</section>
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Execute</center>

-  It is mandatory to use a configuration file 
-  Listening for connections to TCP port 26379
```
redis-server /path/to/sentinel.conf --sentinel
```

</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Fundamentals</center>

- You need at least <span class="zf-color">three Sentinel</span> instances for a robust deployment.
- The Sentinel instances should be placed into machines that are believed to <span class="zf-color">fail in an independent way</span>.
- Sentinel + Redis distributed system does <span class="zf-color">not guarantee</span> that acknowledged writes are retained during failures
- You need Sentinel <span class="zf-color">support in your clients</span>. Popular client libraries have Sentinel support, but not all.
- Sentinel, Docker, or other forms of NAT or Port Mapping should be <span class="zf-color">mixed with care</span>
</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Configuring Sentinel 2</center>

 
- <span class="zf-color">quorum</span> is the number of Sentinels that need to agree
- <span class="zf-color">down-after-milliseconds</span> is the time in milliseconds an instance should not be reachable
- <span class="zf-color">failover-timeout</span> if a Sentinel voted another Sentinel for the failover of a given master, it will wait some time to try to failover the same master again
- <span class="zf-color">parallel-syncs</span> sets the number of slaves that can be reconfigured to use the new master after a failover at the same time
</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Configuring Minimal</center>

```
sentinel monitor server1 127.0.0.1 6379 2
sentinel down-after-milliseconds server1 60000
sentinel failover-timeout server1 180000
sentinel parallel-syncs server1 1

sentinel monitor server2 192.168.1.3 6380 4
sentinel down-after-milliseconds server2 10000
sentinel failover-timeout server2 180000
sentinel parallel-syncs server2 5
```


</script></section>

<!-- *************** SLIDES BEGIN ********************* -->

<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Commands</center>

- num-other-sentinels
- flags is just master (s_down or o_down)
- num-slaves
```
SENTINEL master server1
SENTINEL slaves server1
SENTINEL sentinels server1
SENTINEL get-master-addr-by-name mymaster
```


</script></section>

<!-- *************** SLIDES BEGIN ********************* -->

<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Testing the failover</center>

Our master no longer reachable, sleeping for 30 seconds
- Each Sentinel <span class="zf-color">detects</span> the master is down with an +sdown event.
- This event is later <span class="zf-color">escalated to +odown</span>, which means that multiple Sentinels agree about the fact the master is not reachable.
- <span class="zf-color">Sentinels vote a Sentinel</span> that will start the first failover attempt.
- The <span class="zf-color">failover happens</span>.
```
redis-cli -p 6379 DEBUG sleep 30
```


</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Sentinel Features</center>

- Sentinel commands (API)
- Reconfiguring Sentinel at Runtime
- Adding or removing Sentinels
- Removing the old master or unreachable slaves.
- Handling of -BUSY state
- Slaves priority
- Sentinel and Redis authentication
- Sentinel clients implementation
- Slaves auto discovery


</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Sentinel Features</center>

- Configuration propagation
- Sentinel persistent state in configuration file
- Redis Sentinel is heavily dependent on the computer time 
for instance in order to understand if an instance is available it remembers the time of the latest successful reply to the PING command, 
and compares it with the current time to understand how old it is.


</script></section>

<!-- *************** SLIDES BEGIN ********************* -->

<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Cluster</center>

- Every Redis Cluster node requires two TCP connections open (TCP port used to serve clients and Cluster bus +10000)
- Clients should never try to communicate with the cluster bus port
- If you don't open both TCP ports, your cluster will not work as expected.
- Currently Redis Cluster does not support NAT


</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Redis Cluster data sharding</center>

- Redis Cluster does not use consistent hashing
- Different form of sharding where every key is conceptually part of what we call an <span class="zf-color">hash slot</span>
- Every node in a Redis Cluster is responsible for a subset of the hash slots
- There are 16384 hash slots in Redis Cluster
- Adding and removing nodes, or changing the percentage of hash slots hold by nodes, does not require any downtime.
- {foo}key and another{foo}key are guaranteed to be in the same hash slot

Note: 
HASH SLOT: CRC16 of the key modulo 16384.


</script></section>

<!-- *************** SLIDES BEGIN ********************* -->

<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Redis Cluster master-slave model</center>

- Redis Cluster uses a master-slave model where every hash slot has from 1 (the master itself) to N replicas 
- When the cluster is created we add a slave node to every master
- However note that if nodes B and B1 fail at the same time Redis Cluster is not able to continue to operate.


</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Redis Cluster consistency</center>

<span style="color:red">Redis Cluster is not able to guarantee strong consistency</span>

- Basically there is a trade-off to take between performance and consistency.

Note:
- The first reason why Redis Cluster can lose writes is because it uses asynchronous replication.
- Your client writes to the master B.
- The master B replies OK to your client.
- The master B propagates the write to its slaves B1, B2 and B3.

</script></section>

<!-- *************** SLIDES BEGIN ********************* -->


<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Cluster configuration</center>

<span class="zf-color">cluster-enabled <yes/no></span>  
<span class="zf-color">cluster-config-file <filename></span> is not an user editable configuration file  
<span class="zf-color">cluster-node-timeout <milliseconds></span> without it being considered as failing and will be failed over by its slaves.   
<span class="zf-color">cluster-slave-validity-factor <factor></span> If set to zero, a slave will always try to failover a master, regardless of the amount of time the link between the master and the slave remained disconnected.   
<span class="zf-color">cluster-migration-barrier <count></span> Minimum number of slaves a master will remain connected with  
<span class="zf-color">cluster-require-full-coverage <yes/no></span>If yes, the cluster stops accepting writes if some percentage of the key space is not covered by any node.

</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Minimal Redis cluster configuration</center>

- The minimal cluster that works as expected requires to contain at least three master nodes.
- But with three masters and three slaves better.
```
port 7000
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
```
</script></section>

<!-- *************** SLIDES BEGIN ********************* -->

<section>
<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>How to</center>

```
mkdir cluster-test
cd cluster-test
mkdir 7000 7001 7002 7003 7004 7005
```
</script></section>
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>How to 2</center>

- Create a redis.conf file inside each of the directories
- Replace the port number 7000 with the right port number
- Copy your redis-server executable into cluster-test directory
- Open 6 terminal tabs in your favorite terminal application.
- Start instance with ../redis-server ./redis.conf
- This ID will be used forever by this specific instance

</script></section>

<!-- *************** SLIDES BEGIN ********************* -->

<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>How to 3</center>

- To create the cluster writing some meaningful configuration to the nodes
- Need redis-trib
- The option --replicas 1 means that we want a   
slave for every master created
```
gem install redis
./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001   
127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
>[OK] All 16384 slots covered
```
</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>How to 4</center>

Using Script
```
create-cluster start
create-cluster create
create-cluster stop
```
</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Resharding</center>

Using redis-trib  
- You only need to specify a single node
```
./redis-trib.rb reshard 127.0.0.1:7000
./redis-trib.rb check 127.0.0.1:7000
```

Note: 
- redis-cli -p 7000 cluster nodes | grep myself
</script></section>

<!-- *************** SLIDES BEGIN ********************* -->

<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Testing the failover</center>

We can identify a cluster and crash it with the following command
```
redis-cli -p 7000 cluster nodes | grep master
redis-cli -p 7002 debug segfault
redis-cli -p 7000 cluster nodes
```

</script></section>

<!-- *************** SLIDES BEGIN ********************* -->

<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Add Node</center>

We can identify a cluster and crash it with the following command
```
./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000
```

Or as a replica
```
./redis-trib.rb add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006 127.0.0.1:7000
[manual] cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
```


</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Removing Node</center>

- To remove a master node it must be empty
- If the master is not empty you need to reshard data away
- An alternative to remove a master node is to perform a manual failover (CLUSTER FAILOVER)
- To remove a slave node just use the del-node command of redis-trib:
```
./redis-trib del-node 127.0.0.1:7000 `<node-id>`
```



</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
<section data-markdown style="text-align: left;">
<script type="text/template">
## <center>Replicas migration</center>

- The cluster will try to migrate a replica from the master that has the greatest number of replicas in a given moment.
- To benefit from replica migration you have just to add a few more replicas to a single master in your cluster, it does not matter what master.
- There is a configuration parameter that controls the replica migration feature that is called cluster-migration-barrier
```
CLUSTER REPLICATE <master-node-id>
```

Note:
Redis Cluster it is possible to reconfigure a slave to replicate with a different master


</script></section>

<!-- *************** SLIDES BEGIN ********************* -->
</section>




<!-- *************** SLIDES END *********************** -->
            
            
     




			</div>

		</div>

		<script src="../assets/vendor/reveal.js/lib/js/head.min.js"></script>
		<script src="../assets/vendor/reveal.js/js/reveal.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: '../assets/vendor/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../assets/vendor/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../assets/vendor/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../assets/vendor/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../assets/vendor/reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: '../assets/vendor/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
